<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>elixir on Riza S</title><link>https://rizasal.github.io/tags/elixir/</link><description>Recent content in elixir on Riza S</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 16 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://rizasal.github.io/tags/elixir/index.xml" rel="self" type="application/rss+xml"/><item><title>Actor Concurrency Model, Message Passing and its Guarantees in Erlang/Elixir</title><link>https://rizasal.github.io/posts/2022-07-16-actor-concurrency/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://rizasal.github.io/posts/2022-07-16-actor-concurrency/</guid><description>&lt;img src="https://rizasal.github.io/posts/2022-07-16-actor-concurrency/images/Erlang_logo.jpeg" alt="Featured image of post Actor Concurrency Model, Message Passing and its Guarantees in Erlang/Elixir" />&lt;h2 id="the-concept">The Concept&lt;/h2>
&lt;p>The actor concurrency model is a conceptual model where an actor represents the primitive unit of computation.
An Actor has 3 responsibilities:&lt;/p>
&lt;ul>
&lt;li>Communication&lt;/li>
&lt;li>Storage&lt;/li>
&lt;li>Processing&lt;/li>
&lt;/ul>
&lt;h3 id="communication">Communication&lt;/h3>
&lt;p>A single actor on its own makes no sense. Actors come in systems and communicate with each other using mailboxes. Each actor is associated with an address and everything in the system would be modeled using actors.&lt;/p>
&lt;h3 id="storage">Storage&lt;/h3>
&lt;p>An actor can have a private internal state. Each actor is completely isolated from each other since no actor can access the state of another. They can only communicate using messages.&lt;/p>
&lt;h3 id="processing">Processing&lt;/h3>
&lt;p>An actor is allowed to do 3 things upon recieving a message&lt;/p>
&lt;ul>
&lt;li>Create more actors&lt;/li>
&lt;li>Send messages to other actors&lt;/li>
&lt;li>Setting the state for the next message&lt;/li>
&lt;/ul>
&lt;p>An example of an actor designating the state for the next message could be incrementing a counter on each message. Each message will be processed synchronously, and in the conceptual model, there is no guarantee on the ordering of messages.&lt;/p>
&lt;p>The actor models falls nicely into a distributed system, as they are completely isolated and the messages can be passed across machines, via adresses.&lt;/p>
&lt;p>Every message will be delivered utmost only once. The delivery of the message itself can be considered as &amp;ldquo;best efforts&amp;rdquo;. Everything else including how the the processes will communicate etc, is left out to the implementors. Let&amp;rsquo;s take a look at Erlang, which is modeled on the concept.&lt;/p>
&lt;h2 id="erlangelixir">Erlang/Elixir&lt;/h2>
&lt;p>&lt;code>&amp;quot;Message passing starts with a Process Identifier. If it exists, the message is inserted into its signal queue. The messages are always copied.&amp;quot;&lt;/code>
&lt;a class="link" href="https://www.erlang.org/blog/message-passing/" target="_blank" rel="noopener"
>ðŸ”—&lt;/a>&lt;/p>
&lt;p>Erlang implements the actor concurrency model, and it&amp;rsquo;s worth looking into the message passing guarantees that it gives.&lt;/p>
&lt;ul>
&lt;li>Signals between two processes are guaranteed to arrive in the order they were sent.&lt;/li>
&lt;/ul>
&lt;p>This process is not the same as an operating system process. In Erlang, processes are lightweight and can be considered as actors
It is important to note that if more than one process sends signals to a common process they can arrive in any order.&lt;/p>
&lt;p>Consider the following scenario:&lt;/p>
&lt;ul>
&lt;li>Process A sends &lt;code>[1,2,3]&lt;/code> to Common Process C.&lt;/li>
&lt;li>Process B sends &lt;code>[4,5,6]&lt;/code> to Common Process C.&lt;/li>
&lt;/ul>
&lt;p>The messages may be recieved by C as &lt;code>[1,2,4,5,6,3]&lt;/code>. The messages sent from A to C will arrive in order they were sent.&lt;/p>
&lt;p>&lt;code>if an entity sends multiple signals to the same destination entity, the order is preserved; that is, if A sends a signal S1 to B, and later sends signal S2 to B, S1 is guaranteed not to arrive after S2. Note that S1 may, or may not have been lost.&lt;/code> &lt;a class="link" href="https://www.erlang.org/doc/reference_manual/processes.html#signal-delivery" target="_blank" rel="noopener"
>ðŸ”—&lt;/a>&lt;/p>
&lt;p>The actual delivery of a message is not guaranteed, &lt;a class="link" href="https://www.erlang.org/faq/academic.html#idm1231" target="_blank" rel="noopener"
>only the order is&lt;/a>.&lt;/p>
&lt;h2 id="implications">Implications&lt;/h2>
&lt;h3 id="fault-tolerance">Fault Tolerance&lt;/h3>
&lt;p>Processes are completely isolated. One process going down does not affect any other part of the system since there is no shared state amongst any of them.
Instead of trying to program defensively and trying to handle every single fault that could happen, we let the process crash, and let a supervising process know what happened.&lt;/p>
&lt;p>The supervisor is responsible for knowing what to do when the process crashes, and can restart the process with known state, or handle the failure with grace.
A supervisor itself may be supervised and this can go up all the way.&lt;/p>
&lt;h3 id="distributed-systems">Distributed Systems&lt;/h3>
&lt;p>Since processes are completely isolated, it does not matter where the processes live, and could be distributed across networks. A process only needs to know the address it needs to send to, and everything else works the same.&lt;/p>
&lt;h3 id="deadlocks">Deadlocks&lt;/h3>
&lt;p>The actor model can still cause deadlocks. Process A and B can end up both waiting for messages from each other, creating a deadlock. Even though this is rare, one should keep this in mind when designing systems.&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.youtube.com/watch?v=7erJ1DV_Tlo" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=7erJ1DV_Tlo&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.brianstorti.com/the-actor-model/" target="_blank" rel="noopener"
>https://www.brianstorti.com/the-actor-model/&lt;/a>&lt;/li>
&lt;li>Interesting Read: &lt;a class="link" href="https://keunwoo.com/notes/rebooting/" target="_blank" rel="noopener"
>https://keunwoo.com/notes/rebooting/&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Cleaner flows with Pattern Matching in Elixir</title><link>https://rizasal.github.io/posts/2022-05-19-pattern-match/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://rizasal.github.io/posts/2022-05-19-pattern-match/</guid><description>&lt;img src="https://rizasal.github.io/posts/2022-05-19-pattern-match/images/preview.png" alt="Featured image of post Cleaner flows with Pattern Matching in Elixir" />&lt;p>Pattern matching is a powerful feature of most Functional Programming languages and allows for a huge improvement in readability.
At it&amp;rsquo;s core, pattern match in Elixir relies on the match operator, the = sign. It tries to match the right hand side with the left hand side.&lt;/p>
&lt;blockquote>
&lt;p>What difference would this have with the == or the === sign that many other languages have?&lt;/p>
&lt;/blockquote>
&lt;p>The match operator allows you to bind variables in addition to checking for a match. Let&amp;rsquo;s understand this through an example&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="go">iex(1)&amp;gt; %{ first_name: &amp;#34;smith&amp;#34;, last_name: last_name } = %{ first_name: &amp;#34;smith&amp;#34;, last_name: &amp;#34;john&amp;#34;}
&lt;/span>&lt;span class="go">&lt;/span>&lt;span class="gp">%&lt;/span>&lt;span class="o">{&lt;/span>first_name: &lt;span class="s2">&amp;#34;smith&amp;#34;&lt;/span>, last_name: &lt;span class="s2">&amp;#34;john&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="go">iex(2)&amp;gt; last_name
&lt;/span>&lt;span class="go">&amp;#34;john&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Whenever a variable is present on the LHS of a match expression, the value of the expression will be assigned into the variable. In the above example, it will give a successful match on any name which has the first_name value as &lt;code>smith&lt;/code> and it will bind the last_name (&amp;ldquo;john&amp;rdquo;) in the &lt;code>last_name&lt;/code> variable. If the &lt;code>first_name&lt;/code> does not match &lt;code>smith&lt;/code> , it will raise a MatchError.&lt;/p>
&lt;h2 id="pattern-match-in-function-parameters">Pattern Match in Function Parameters&lt;/h2>
&lt;p>Let&amp;rsquo;s start with an example&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">IO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># print(1) =&amp;gt; &amp;#34;one&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">IO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;two&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># print(2) =&amp;gt; &amp;#34;two&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_n&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">IO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;noop&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># print(3) =&amp;gt; &amp;#34;noop&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>The above example has three implementations defined for print
The overloaded print function will start pattern matching on the arguments with each definition until it finds a match or it would raise a &lt;code>FunctionClauseError&lt;/code>
Functions are matched for parameters from top to bottom in the order of definition&lt;/p>
&lt;p>Looking at a more complicated example,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">transform&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:italics&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;i&amp;gt; &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> &amp;lt;/i&amp;gt;&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">transform&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:bold&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;b&amp;gt; &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> &amp;lt;/b&amp;gt;&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">transform&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:strikethrough&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;s&amp;gt; &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> &amp;lt;/s&amp;gt;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Here the HTML can be transformed to add an italics/bold/strikethrough surrounding it, by
changing the way we call transform with the second argument.&lt;/p>
&lt;p>You could extract variables inside different types such as tuples, maps and lists using pattern matching in function parameters as well&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">switcheroo&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">}),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="c1"># switcheroo({1,2}) =&amp;gt; {2, 1}&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">extract_name&lt;/span>&lt;span class="p">(%{&lt;/span>&lt;span class="ss">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">}),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">name&lt;/span>
&lt;span class="c1"># extract_name(%{name: &amp;#34;john&amp;#34;, ...}) =&amp;gt; &amp;#34;john&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">extract_head&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">tail&lt;/span>&lt;span class="p">]),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">head&lt;/span>
&lt;span class="c1"># extract_head([1,2,3]) =&amp;gt; 1&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">name_ends_with_john?&lt;/span>&lt;span class="p">(%{&lt;/span>&lt;span class="ss">first_name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">first_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">last_name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;john&amp;#34;&lt;/span>&lt;span class="p">}),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">true&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">name_ends_with_john?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">false&lt;/span>
&lt;span class="c1"># name_ends_with_john(%{first_name: &amp;#34;smith&amp;#34;, last_name: &amp;#34;john&amp;#34;}) =&amp;gt; true&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="cleaner-flows-with-pattern-matching">Cleaner flows with Pattern Matching&lt;/h2>
&lt;p>Here is an example for the merge function in Merge Sort, which merges two already sorted arrays. Note how the pattern match in the function arguments combined with the &lt;code>|&lt;/code> operator improves readabliity.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">([],&lt;/span> &lt;span class="n">list_b&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">list_b&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list_a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">list_a&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list_a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">head_a&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">rest_a&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">list_b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">head_b&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">rest_b&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">head_a&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">head_b&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="n">head_a&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rest_a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">list_b&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="n">head_b&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list_a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rest_b&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="doing-more-with-guards">Doing more with Guards&lt;/h2>
&lt;p>Guard clauses restrict the the parameters when pattern matching in functions. Consider a function to check whether the elements in a given list doubles with every element.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir"> &lt;span class="kd">def&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">tail&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">_&lt;/span>&lt;span class="p">]])&lt;/span> &lt;span class="ow">when&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tail&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">]),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">true&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>In addition to matching on the function parameters, &lt;code>when x==2*y&lt;/code> should also be true for the function clause to match.&lt;/p>
&lt;p>Consider the following example for checking of valid parantheses.
The &lt;code>&amp;lt;&amp;lt;&amp;quot;(&amp;quot;, rest::binary&amp;gt;&amp;gt;&lt;/code> format allows for us to pattern match on strings, where the end of the string is allowed to be of variable length and is stored in &lt;code>rest&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&amp;lt;&amp;lt;&lt;/span>&lt;span class="s2">&amp;#34;(&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rest&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">binary&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;,&lt;/span> &lt;span class="n">open_count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close_count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rest&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">open_count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close_count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&amp;lt;&amp;lt;&lt;/span>&lt;span class="s2">&amp;#34;)&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rest&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">binary&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;,&lt;/span>
&lt;span class="n">open_count&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">close_count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ow">when&lt;/span> &lt;span class="n">close_count&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">open_count&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rest&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">open_count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close_count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">true&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>All in all, pattern matching is a very useful feature enhancing the readability.&lt;/p></description></item></channel></rss>