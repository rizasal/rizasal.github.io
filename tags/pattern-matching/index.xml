<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pattern-matching on Riza S</title><link>https://rizasal.github.io/tags/pattern-matching/</link><description>Recent content in pattern-matching on Riza S</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://rizasal.github.io/tags/pattern-matching/index.xml" rel="self" type="application/rss+xml"/><item><title>Cleaner flows with Pattern Matching in Elixir</title><link>https://rizasal.github.io/posts/2022-05-19-pattern-match/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://rizasal.github.io/posts/2022-05-19-pattern-match/</guid><description>&lt;img src="https://rizasal.github.io/posts/2022-05-19-pattern-match/images/preview.png" alt="Featured image of post Cleaner flows with Pattern Matching in Elixir" />&lt;p>Pattern matching is a powerful feature of most Functional Programming languages and allows for a huge improvement in readability.
At it&amp;rsquo;s core, pattern match in Elixir relies on the match operator, the = sign. It tries to match the right hand side with the left hand side.&lt;/p>
&lt;blockquote>
&lt;p>What difference would this have with the == or the === sign that many other languages have?&lt;/p>
&lt;/blockquote>
&lt;p>The match operator allows you to bind variables in addition to checking for a match. Let&amp;rsquo;s understand this through an example&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="go">iex(1)&amp;gt; %{ first_name: &amp;#34;smith&amp;#34;, last_name: last_name } = %{ first_name: &amp;#34;smith&amp;#34;, last_name: &amp;#34;john&amp;#34;}
&lt;/span>&lt;span class="go">&lt;/span>&lt;span class="gp">%&lt;/span>&lt;span class="o">{&lt;/span>first_name: &lt;span class="s2">&amp;#34;smith&amp;#34;&lt;/span>, last_name: &lt;span class="s2">&amp;#34;john&amp;#34;&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="go">iex(2)&amp;gt; last_name
&lt;/span>&lt;span class="go">&amp;#34;john&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Whenever a variable is present on the LHS of a match expression, the value of the expression will be assigned into the variable. In the above example, it will give a successful match on any name which has the first_name value as &lt;code>smith&lt;/code> and it will bind the last_name (&amp;ldquo;john&amp;rdquo;) in the &lt;code>last_name&lt;/code> variable. If the &lt;code>first_name&lt;/code> does not match &lt;code>smith&lt;/code> , it will raise a MatchError.&lt;/p>
&lt;h2 id="pattern-match-in-function-parameters">Pattern Match in Function Parameters&lt;/h2>
&lt;p>Let&amp;rsquo;s start with an example&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">IO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># print(1) =&amp;gt; &amp;#34;one&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">IO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;two&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># print(2) =&amp;gt; &amp;#34;two&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_n&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nc">IO&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">puts&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;noop&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># print(3) =&amp;gt; &amp;#34;noop&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>The above example has three implementations defined for print
The overloaded print function will start pattern matching on the arguments with each definition until it finds a match or it would raise a &lt;code>FunctionClauseError&lt;/code>
Functions are matched for parameters from top to bottom in the order of definition&lt;/p>
&lt;p>Looking at a more complicated example,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">transform&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:italics&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;i&amp;gt; &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> &amp;lt;/i&amp;gt;&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">transform&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:bold&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;b&amp;gt; &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> &amp;lt;/b&amp;gt;&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">transform&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">:strikethrough&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;s&amp;gt; &lt;/span>&lt;span class="si">#{&lt;/span>&lt;span class="n">html&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> &amp;lt;/s&amp;gt;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Here the HTML can be transformed to add an italics/bold/strikethrough surrounding it, by
changing the way we call transform with the second argument.&lt;/p>
&lt;p>You could extract variables inside different types such as tuples, maps and lists using pattern matching in function parameters as well&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">switcheroo&lt;/span>&lt;span class="p">({&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">}),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="c1"># switcheroo({1,2}) =&amp;gt; {2, 1}&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">extract_name&lt;/span>&lt;span class="p">(%{&lt;/span>&lt;span class="ss">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">}),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">name&lt;/span>
&lt;span class="c1"># extract_name(%{name: &amp;#34;john&amp;#34;, ...}) =&amp;gt; &amp;#34;john&amp;#34;&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">extract_head&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">head&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">tail&lt;/span>&lt;span class="p">]),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">head&lt;/span>
&lt;span class="c1"># extract_head([1,2,3]) =&amp;gt; 1&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">name_ends_with_john?&lt;/span>&lt;span class="p">(%{&lt;/span>&lt;span class="ss">first_name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">first_name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">last_name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;john&amp;#34;&lt;/span>&lt;span class="p">}),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">true&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">name_ends_with_john?&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">false&lt;/span>
&lt;span class="c1"># name_ends_with_john(%{first_name: &amp;#34;smith&amp;#34;, last_name: &amp;#34;john&amp;#34;}) =&amp;gt; true&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="cleaner-flows-with-pattern-matching">Cleaner flows with Pattern Matching&lt;/h2>
&lt;p>Here is an example for the merge function in Merge Sort, which merges two already sorted arrays. Note how the pattern match in the function arguments combined with the &lt;code>|&lt;/code> operator improves readability.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">([],&lt;/span> &lt;span class="n">list_b&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">list_b&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list_a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[]),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">list_a&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list_a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">head_a&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">rest_a&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">list_b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">head_b&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">rest_b&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">head_a&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">head_b&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="n">head_a&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rest_a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">list_b&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="n">head_b&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list_a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rest_b&lt;/span>&lt;span class="p">)]&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="doing-more-with-guards">Doing more with Guards&lt;/h2>
&lt;p>Guard clauses restrict the the parameters when pattern matching in functions. Consider a function to check whether the elements in a given list doubles with every element.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir"> &lt;span class="kd">def&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">tail&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">_&lt;/span>&lt;span class="p">]])&lt;/span> &lt;span class="ow">when&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tail&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">]),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">true&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_doubling&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>In addition to matching on the function parameters, &lt;code>when x==2*y&lt;/code> should also be true for the function clause to match.&lt;/p>
&lt;p>Consider the following example for checking of valid parantheses.
The &lt;code>&amp;lt;&amp;lt;&amp;quot;(&amp;quot;, rest::binary&amp;gt;&amp;gt;&lt;/code> format allows for us to pattern match on strings, where the end of the string is allowed to be of variable length and is stored in &lt;code>rest&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-elixir" data-lang="elixir">&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&amp;lt;&amp;lt;&lt;/span>&lt;span class="s2">&amp;#34;(&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rest&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">binary&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;,&lt;/span> &lt;span class="n">open_count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close_count&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rest&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">open_count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close_count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&amp;lt;&amp;lt;&lt;/span>&lt;span class="s2">&amp;#34;)&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rest&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">binary&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;,&lt;/span>
&lt;span class="n">open_count&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">close_count&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ow">when&lt;/span> &lt;span class="n">close_count&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">open_count&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rest&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">open_count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">close_count&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">end&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">true&lt;/span>
&lt;span class="kd">def&lt;/span> &lt;span class="n">is_balanced&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">_&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="ss">do&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="no">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>All in all, pattern matching is a very useful feature enhancing the readability.&lt;/p></description></item></channel></rss>